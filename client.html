<!doctype html>
<meta charset="utf-8">
<title> client </title>

<style>
  body {
    margin: 0px;
  }
  form {
    position: absolute;
    right: 0px;
    top: 0px;
  }
  form input {
    display: block;
    height: 20px;
    width: 30px;
    margin: 10px;
  }
  .hidden {
    display: none;
  }
</style>

<form id=bar action=http://localhost:8080/upload enctype=multipart/form-data method=post target=uploader>
  <input name=color  type=color>
  <input name=width  type=number value=1 min=1 max=10>
  <input name=tool   type=radio  value=pen checked> draw
  <input name=tool   type=radio  value=eraser> erase
  <input name=tool   type=radio  value=hand> move
 <input name=upload  type=file>
  <input type=submit value=submit>
</form>

<canvas id=canvas resize></canvas>

<iframe id=uploader src=http://localhost:8080 class=hidden height=500 width=700></iframe>

<script src=./lib/paper.js></script>
<script src=./lib/webrtc.js></script>
<script>

  var channel = new WebRTC.DataChannel('ws://localhost:1234'),
      bar = document.getElementById('bar');

  paper.install(window);

  window.onload = function () {
    paper.setup(canvas);

    // create the state
    var path, handle, objects = [], history = [];
    var currentRevision = -1;
    var historyPointer= -1;

    /* UTILS */

    function redraw (since, data) {
      // first we erase the object after since
      currentRevision = since + data.length - 1;
      console.log('currentRevision', currentRevision);
      for (var i = since; i <= currentRevision ; i++) {
        if (data[i] != null)
          objects[i] = rawToPath(data[i]);
      }
      paper.view.draw();
    }

    function rawToPath (raw) {
      var path = new paper.Path();
      path.strokeColor = raw.color;
      path.strokeWidth = raw.width;

      for (var i = 0 ; i < raw.curves.length ; i++) {
        path.add(new paper.Point(raw.curves[i].pointx, raw.curves[i].pointy));
        path.segments[i].handleIn = new paper.Point(raw.curves[i].handleInx,raw.curves[i].handleIny);
        path.segments[i].handleOut = new paper.Point(raw.curves[i].handleOutx,raw.curves[i].handleOuty);
      }
      return path;
    }

    function pathToRaw (path) {
      var curves = [];
      for (var i = 0 ; i < path.segments.length ; i++) {
        var seg = path.segments[i];
        curves.push({
          pointx: seg._point._x,
          pointy: seg._point._y,
          handleInx: seg._handleIn._x,
          handleIny: seg._handleIn._y,
          handleOutx: seg._handleOut._x,
          handleOuty: seg._handleOut._y
        });
      }
      return {
        curves: curves,
        color: path.color,
        width: path.strokeWidth
      };
    }
    // function building the client OT history
    function emitOperation (event, data, lostData) {
      channel.send(event, data);
      if (event == 'finalize' || event == 'move' || event == 'delete'){
        historyPointer = history.push( {event: event, data: data, lostData: lostData} ) - 1;
        console.log('historyPointer', historyPointer);
      }
    }

    function undo () {
      if (historyPointer >= 0) {
        var operation = history[historyPointer];
        //console.log('undo', operation);
        historyPointer--;
        switch (operation.event) {
        case 'finalize':
          channel.send('delete', operation.data.handle);
          channel.handlers['delete'] (operation.data.handle);
          break;
        case 'move':
          var inverse = new paper.Point(0 - operation.data.move.x, 0 - operation.data.move.y);
          channel.send('move', { handle: operation.data.handle, move: inverse });
          channel.handlers['move'] ({ handle: operation.data.handle, move: inverse });
          break;
        case 'delete':
          channel.send('finalize', {handle: operation.data, obj: operation.lostData});
          channel.handlers['finalize'] ({handle: operation.data, obj: operation.lostData});
          break;
        }
      }
    }

    function redo () {
      if (historyPointer < (history.length - 1)) {
        historyPointer++;
        var operation = history[historyPointer];
        //console.log('historyPointer', operation);
        channel.send(operation.event,operation.data);
        channel.handlers[operation.event] (operation.data);
      }
    }

    /* NETWORK */

    // TODO make this the answer to "my handle is objects.length"
    channel.on('state', function(data) {
      console.log('state',data);
      redraw(0, data);
    });

    // receive points from others
    channel.on('point', function(data) {
      console.log('point', handle);
      // the handle is bigger than our current revision: 
      // ==> we receive a new object!
      if (currentRevision < data.handle) { 
        objects[data.handle] = new paper.Path();
        currentRevision = data.handle;
        objects[data.handle].color = data.point.color; // don't remove this
        objects[data.handle].strokeColor = data.point.color;
        objects[data.handle].strokeWidth = data.point.width;
        console.log('creation', objects[data.handle]);
      }

      // the handle is smaller than our revision but we don't have the object:
      // ==> we lose sync
      if (objects[data.handle] == null) {
        console.error('missed object', data.handle, ', ask for new state');
      } else { // expected behavior: add the new point to the object
        console.log('expected', objects[data.handle]);
        objects[data.handle].add(data.point);
        paper.view.draw();
      }
    });

    // receive raster images
    channel.on('raster', function(data) {
      console.log('raster', data);
      var img = document.createElement('img');
      img.id = 'img' + data.id;
      img.src = 'http://localhost:8080/img/' + data.id;
      img.style.display = 'none';
      img.onload = function() {
        var raster = new paper.Raster(img.id);
        paper.view.draw();
      };
      document.body.appendChild(img);
    });

    // the server gives us the handle to our current object
    channel.on('handle', function(data) {
      console.log('handle', data);
      handle = data;
      if (handle !== currentRevision + 1)
        console.error('our handle was late and we are doomed, ask for new state');
      objects[handle] = path;
      currentRevision++;
    });

    // when other objects are finalized
    channel.on('finalize', function(data) {
      console.log('finalize', data);
      if(objects[data.handle])
        objects[data.handle].remove();
      objects[data.handle] = rawToPath(data.obj);
      paper.view.draw();
    });

    // relative move of an object from it's current location
    channel.on('move', function(data) {
      console.log('move', data);
      objects[data.handle].translate(data.move);
      paper.view.draw();
    });

    channel.on('delete', function(handle) {
      console.log('delete', handle);
      objects[handle].remove();
      paper.view.draw();
    });

    channel.on('close', function() {
      // TODO try to reconnect
      //channel = new WebRTC.DataChannel('ws://localhost:1234');
    });

    /* TOOLS */

    // create the tools
    var tool = new Tool(),
        tools = {};

    tool.onMouseDown = function (event) {
      var id = document.querySelector('input[name=tool]:checked').value;
      if (tools[id].onMouseDown !== undefined) {
        console.log('calling',id,'onMouseDown');
        tools[id].onMouseDown(event);
      }
    };

    tool.onMouseDrag = function (event) {
      var id = document.querySelector('input[name=tool]:checked').value;
      if (tools[id].onMouseDrag !== undefined) {
        console.log('calling',id,'onMouseDrag');
        tools[id].onMouseDrag(event);
      }
    };

    tool.onMouseUp = function (event) {
      var id = document.querySelector('input[name=tool]:checked').value;
      if (tools[id].onMouseUp !== undefined) {
        console.log('calling',id,'onMouseUp');
        tools[id].onMouseUp(event);
      }
    };

    // PEN

    tools.pen = {};

    // A click begins the drawing of a new object
    tools.pen.onMouseDown = function (event) {
      path = new paper.Path();
      var point = event.point;
      point.color = bar.color.value;
      point.width = bar.width.value;
      emitOperation('point', point);
      path.add(point); 
      path.color = point.color; // duplicated information !
      path.strokeColor = point.color;
      path.strokeWidth = point.width;
    };

    // When the user drags the mouse, add points to current object and send them
    tools.pen.onMouseDrag = function (event) {
      path.add(event.point);
      emitOperation('point', event.point);
    };

    // When the mouse is released, we compress the current object
    tools.pen.onMouseUp = function (event) {
      path.simplify(10);
      paper.view.draw();
      emitOperation('finalize', { handle: handle, obj: pathToRaw(path) });
    };

    // ERASER
    
    tools.eraser = {};

    var eraserHitOptions = {
      segments: true,
      stroke: true,
      fill: true,
      tolerance: 6
    };

    tools.eraser.onMouseDown = tools.eraser.onMouseDrag = function(event) {
      for(var i = currentRevision ; i >= 0 ; i--){
        if(objects[i] !== undefined){
          if(objects[i].hitTest(event.point,eraserHitOptions) != null){
            emitOperation('delete', i, pathToRaw(objects[i]));
            objects[i].remove();
          }
        }
      }
      paper.view.draw();
    };

    // HAND

    tools.hand = {
      handle: undefined, // handle of the dragged object
      dragged: undefined, // dragged object itself
      from: undefined // initial position of the object
    };

    var handHitOptions = {
      segments: true,
      stroke: true,
      fill: true,
      tolerance: 6
    };

    tools.hand.onMouseDown = function(event) {
      path = new paper.Path();
      path.add(event.point);
      var selected = currentRevision + 1;
      var hit = false; 
      while (!hit && selected >= 0) {
        selected--;
        if(objects[selected] !== undefined){
          if(objects[selected].hitTest(event.point,handHitOptions) != null){
            hit = true;
            tools.hand.handle = selected;
            tools.hand.dragged = objects[selected];
            tools.hand.from = event.point;
          }
        }
      }
    };

    tools.hand.onMouseDrag = function(event) {
      if(tools.hand.dragged != undefined){
        var move = new paper.Point(event.point.x - tools.hand.from.x, event.point.y - tools.hand.from.y) ;
        tools.hand.from = event.point;
        tools.hand.dragged.translate(move);
        emitOperation('move', { handle: tools.hand.handle, move: move });
        paper.view.draw();
      }
    };

    tools.hand.onMouseUp = function(event) {
      selected = undefined;
      from = undefined;
    };

    // HISTORY
  
    addEventListener('keydown', function(event) {
      if (event.ctrlKey)
        if (event.keyCode == 90){ // ctrl+z
          console.log('keydown', event);
          undo();
        }
        else if (event.keyCode == 89) // ctrl+v
          redo();
    });
  };

</script>
